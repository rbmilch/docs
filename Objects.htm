<!DOCTYPE HTML>
<html>
<head>
<title>Objekte</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> ist in AutoHotkey ein abstrakter Datentyp, das drei Grundfunktionen bereitstellt:</p>
<ul>
  <li>GET - Abrufen eines Wertes.</li>
  <li>SET - Setzen eines Wertes.</li>
  <li>CALL - Aufrufen einer Methode (eine Funktion, die das Zielobjekt beeinflusst).</li>
</ul>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung zu Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
</ul>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Es gibt folgende Objekttypen:</p>
<ul>
  <li><a href="objects/Object.htm"><b>Object</b></a> - skriptfähiges assoziatives Array.</li>
  <li><a href="objects/File.htm">File</a> - stellt eine Schnittstelle für die Dateibearbeitung bereit.</li>
  <li><a href="objects/Functor.htm">Funktionsobjekte</a> - <a href="objects/Func.htm">Func</a>, <a href="objects/Functor.htm#BoundFunc">BoundFunc</a> oder <a href="objects/Functor.htm#User-Defined">benutzerdefiniert</a>.</li>
  <li><a href="commands/ComObjCreate.htm">ComObject</a> - Wrappt eine IDispatch-Schnittstelle (ein COM oder "Automatisierungsobjekt").</li>
</ul>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlagen</a> - <a href="#Usage_Simple_Arrays">Einfache Arrays</a>, <a href="#Usage_Associative_Arrays">Assoziative Arrays</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a>, <a href="#Usage_Remarks">Bemerkungen</a></li>
  <li><a href="#Extended_Usage">Erweiterte Grundlagen</a> - <a href="#Function_References">Funktionsverweise</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>, <a href="#Usage_Arrays_of_Functions">Arrays mit Funktionen</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#Custom_Prototypes">Prototypen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Meta-Funktionen</a></li>
  <li><a href="#Default_Base_Object">Standard-Base-Objekt</a> - <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#Implementation_Pointers">Objekt-Pointer</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlagen</h2>

<h3 id="Usage_Simple_Arrays">Einfache Arrays</h3>
<p>Erstellen eines Arrays:</p>
<pre>Array := [Element1, Element2, ..., ElementN]
Array := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Index]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Index] := Wert</pre>
<p>Einfügen beliebig vieler Elemente ab einem bestimmten Index:</p>
<pre>Array.<a href="objects/Object.htm#InsertAt">InsertAt</a>(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder von mehreren Elementen:</p>
<pre>Array.<a href="objects/Object.htm#Push">Push</a>(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#RemoveAt">RemoveAt</a>(Index)</pre>
<p>Entfernen des letzten Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Pop">Pop</a>()</pre>
<p><a href="objects/Object.htm#MinMaxIndex">MinIndex</a> und <a href="objects/Object.htm#MinMaxIndex">MaxIndex</a>/<a href="objects/Object.htm#Length">Length</a> geben, sofern das Array nicht leer ist, den niedrigsten und höchsten Index des Arrays zurück. Während der niedrigste Index fast immer 1 ist, wird MaxIndex üblicherweise die Anzahl der Elemente zurückgeben. Wenn keine Integer-Keys vorhanden sind, wird MaxIndex eine leere Zeichenkette und Length eine 0 zurückgeben. Um die Inhalte des Arrays zu durchlaufen, benutzt man entweder den Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>array := ["eins", "zwei", "drei"]

<em>; Durchläuft das Array von 1 bis zu seinem Ende:</em>
<a href="commands/Loop.htm">Loop</a> % array.Length()
    MsgBox % array[A_Index]

<em>; Enumeriert die Inhalte des Arrays:</em>
<a href="commands/For.htm">For</a> index, wert in array
    MsgBox % "Element " index " ist '" wert "'"
</pre>

<span id="Arrays"></span><h3 id="Usage_Associative_Arrays">Assoziative Arrays</h3>
<p>Ein assoziatives Array ist ein Objekt, das mehrere eindeutige Keys (Schlüssel) und mehrere Values (Werte) enthält, die jeweils miteinander verbunden sind. Keys können Zeichenketten, Integer oder Objekte sein. Values beliebige Typen. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>Array := {KeyA: ValueA, KeyB: ValueB, ..., KeyZ: WertZ}
Array := Object("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Bei der <code>{Key:Value}</code>-Schreibweise muss der Key, sofern dieser nur aus Wortzeichen besteht, nicht in Anführungszeichen gesetzt werden. Der Key kann ein beliebiger Ausdruck sein, aber um eine Variable als Key zu benutzen, muss sie von runden Klammern umschlossen sein. Zum Beispiel wäre sowohl <code>{(KeyVar): Value}</code> als auch <code>{GetKey(): Value}</code> eine gültige Angabe.</p>
<p>Abrufen eines Elements:</p>
<pre>Value := Array[Key]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Key] := Value</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Delete">Delete</a>(Key)</pre>
<p>Enumerieren von Elementen:</p>
<pre>array := {zehn: 10, zwanzig: 20, dreißig: 30}
<a href="commands/For.htm">For</a> key, value in array
    MsgBox %key% = %value%</pre>
<p>Assoziative Arrays können lückenhaft gefüllt werden - zum Beispiel enthält <code>{1: "a", 1000: "b"}</code> nur zwei Key-Value-Paare, nicht 1000.</p>
<p id="same_thing">In AutoHotkey v1.x sind einfache Arrays und assoziative Arrays funktionsgemäß identisch. Solange man aber <code>[]</code> als einfaches lineares Array behandelt, wird sichergestellt, dass dessen Rolle eindeutig bleibt, und die Chance erhöht, dass Ihr Skript auch mit einer zukünftigen Version von AutoHotkey noch funktionieren wird, wo der Unterschied zwischen einfachem und assoziativem Array eventuell erkennbar sein muss.</p>

<h3 id="Usage_Objects">Objekte</h3>
<p>Bei allen Objekttypen kann die Schreibweise <code>Objekt.DirektGeschriebenerKey</code> benutzt werden, um auf eine Eigenschaft, ein Array oder eine Methode zuzugreifen. Hierbei ist <em>DirektGeschriebenerKey</em> ein Identifikator oder Integer und <em>Objekt</em> ein beliebiger Ausdruck. Identifikatoren sind Zeichenketten ohne Anführungszeichen, die aus alphanumerischen Zeichen, Unterstrich und seit <span class="ver">[v1.1.09]</span> aus ASCII-fremden Zeichen bestehen können. Zum Beispiel wäre <code>match.Pos</code> das gleiche wie <code>match["Pos"]</code>, oder <code>arr.1</code> das gleiche wie <code>arr[1]</code>. Es darf kein Leerzeichen nach dem Punkt erfolgen.</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen einer Eigenschaft:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<p>Setzen einer Eigenschaft:</p>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Aufrufen einer Methode:</p>
<pre>Rückgabewert := Objekt.Methode(Parameter)</pre>
<p>Aufrufen einer Methode mit einem errechneten Methodennamen:</p>
<pre>Rückgabewert := Object[Methodenname](Parameter)</pre>
<p>Einige Eigenschaften von COM-Objekten und benutzerdefinierten Objekten können Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Parameter]
Objekt.Eigenschaft[Parameter] := Wert</pre>
<p><strong>Siehe auch</strong>: <a href="objects/Object.htm">Objekt</a>, <a href="objects/File.htm">File-Objekt</a>, <a href="objects/Func.htm">Func-Objekt</a>, <a href="commands/ComObjCreate.htm">COM-Objekt</a></p>
<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Zurzeit wird <code><span class="dull">x</span>.y[z]<span class="dull">()</span></code> als <code><span class="dull">x</span>["y", z]<span class="dull">()</span></code> behandelt, aber nicht unterstützt. Als Übergangslösung kann <code><span class="red">(</span><span class="dull">x.y</span><span class="red">)</span>[z]()</code> benutzen werden, um <code>x.y</code> zuerst auswerten zu lassen und dann das Ergebnis als Ziel des Methodenaufrufs zu verwenden. Beachten Sie, dass <code>x.y[z].Call()</code> diese Einschränkung nicht hat, weil es genauso wie <code>(x.y[z]).Call()</code> ausgewertet wird.</li></ul>

<h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald der letzte Verweis auf ein Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Ein Verweis, der in einer Variable gespeichert ist, wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt den letzten Verweis frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Außerdem wird ein Verweis, der in einem Feld eines anderen Objekts gespeichert ist, freigegeben, wenn dieses Feld irgendeinen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird. Dies gilt auch für Arrays, weil sie quasi das gleiche wie Objekte sind.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt und gibt das zweite Objekt frei.</em></pre>
<p id="Circular_References">Da alle Verweise auf ein Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn beispielsweise <code>x.child</code> auf <code>y</code> verweist und <code>y.parent</code> auf <code>x</code> verweist, würde es nicht genügen, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch einen Verweis auf das Child-Objekt enthält, und umgekehrt. Um diese Situation in den Griff zu bekommen, entfernt man den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Wenn die Zeile darüber fehlen würde, könnten die Objekte auf diese Weise nicht freigegeben werden.</em>
</pre>
<p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h3 id="Usage_Remarks">Bemerkungen</h3>

<h4>Syntax</h4>
<p>Alle Objekttypen unterstützen sowohl die Arraysyntax (eckige Klammern) als auch die Objektsyntax (Punkte).</p>
<p>Darüber hinaus können Objektverweise selbst auch in Ausdrücken verwendet werden:</p>
<ul>
  <li>Ein Objektverweis und irgendein anderer Wert, die via <code>= == != &lt;&gt;</code> verglichen werden, werden nur als gleich angesehen, wenn beide Werte auf dasselbe Objekt verweisen.</li>
  <li>Bei Anweisungen wie <code>if obj</code>, <code>!obj</code> oder <code>obj ? x : y</code> ist der logische Wert eines Objekts immer <i>True</i>.</li>
  <li>Eine Objektadresse kann mithilfe des <code>&amp;</code>-Operators abgerufen werden. So eine Adresse identifiziert eindeutig das Objekt - von seiner Erstellung bis zur letzten <a href="#Refs">Freigabe</a> seines Verweises.</li>
</ul>
<p>Ein Objekt wird als leere Zeichenkette behandelt, wenn es in einem Kontext verwendet wird, wo ein Objekt nicht erwartet wird. Zum Beispiel würde <code>MsgBox %objekt%</code> eine leere MsgBox anzeigen und <code>objekt + 1</code> eine leere Zeichenkette zurückgeben. Verlassen Sie sich nicht auf dieses Verhalten, weil es noch geändert werden könnte.</p>
<p>Wenn unmittelbar nach einem Methodenaufruf ein Zuweisungsoperator erfolgt, werden die runden Klammern als eckige Klammern behandelt, demzufolge wäre dies das gleiche wie, als würde man Parameter für eine Eigenschaft setzen. Zum Beispiel sind die folgenden Zeilen funktionsgemäß identisch:</p>
<pre>obj.item(x) := y
obj.item[x] := y</pre>
<p id="cassign">Verbundzuweisungen wie <code>x.y += 1</code> und <code>--arr[1]</code> werden unterstützt.</p>
<p><span class="ver">[v1.1.20+]:</span> Parameter können beim Abrufen oder Setzen von Eigenschaften weggelassen werden. Zum Beispiel <code>x[,2]</code>. Skripte können damit Standardwerte für Parameter in <a href="#Custom_Classes_property">Eigenschaften</a> und <a href="#Meta_Functions">Meta-Funktionen</a> definieren. Der Methodenname kann zudem komplett weggelassen werden, wie z. B. in <code>x[](a)</code>. Skripte können damit einen Standardwert für den ersten Parameter der __Call-<a href="#Meta_Functions">Meta-Funktion</a> definieren, um zu verhindern, dass er ohne Wert weitergereicht wird. Beachten Sie, dass diese Schreibweise einen anderen Effekt hat als <code>x.(a)</code>, das <code>x[""](a)</code> entspricht. Wenn man den Eigenschafts- oder Methodennamen beim Aufrufen eines COM-Objekts weglässt, wird sein "Standardelement" aufgerufen.</p>

<h4>Keys</h4>
<p>Es gibt einige Einschränkungen, welche Werte als Keys innerhalb von Objekten, die mit <code>[]</code>, <code>{}</code> oder dem <code>new</code>-Operator erstellt wurden, verwendet werden können:</p>
<ul>
  <li>Integer-Keys werden unter Verwendung des nativen vorzeichenbehafteten Integer-Typs gespeichert. AutoHotkey 32-Bit unterstützt Integer-Keys im Bereich von -2147483648 bis 2147483647. AutoHotkey unterstützt 64-Bit-Integer, aber nur die 64-Bit-Version von AutoHotkey kann den vollständigen Zahlenbereich des 64-Bit-Integers als Objekt-Key nutzen.</li>
  <li>Der oben genannte Punkt ist der Grund, warum das Zeichenkettenformat von Integer-Werten nicht beibehalten wird. Zum Beispiel ist <code>x[0x10]</code> dasselbe wie <code>x[16]</code> und <code>x[00016]</code>. Dies gilt auch für numerische Zeichenketten ohne Dezimalpunkt.</li>
  <li>In Anführungszeichen gesetzte Zeichenketten werden in v1.x als rein nicht-numerisch angesehen, demzufolge ist <code>x[1]</code> <i>nicht</i> dasselbe wie <code>x["1"]</code>. Die Verkettung einer in Anführungszeichen gesetzte Zeichenkette mit einem anderen Wert (z. B. <code>"0x" x</code>) wird auch als rein nicht-numerisch angesehen. Allerdings gilt das nicht für Variablen, demzufolge ist <code>x[1]</code> dasselbe wie <code>x[y:="1"]</code>. Dieses Problem wird in <a href="https://autohotkey.com/v2/">AutoHotkey v2</a> behoben, deshalb sollte man vermeiden, in Anführungszeichen gesetzte Zahlen als Keys zu verwenden.</li>
  <li>Gleitkommazahlen werden nicht als Keys unterstützt - stattdessen werden sie in Zeichenketten umgewandelt. In v1.x werden direkt geschriebene Gleitkommazahlen ihr ursprüngliches Format beibehalten, während reine Gleitkommazahlen (wie z. B. das Ergebnis von <code>0+1.0</code> oder <code>Sqrt(y)</code>) gezwungen werden, auf das aktuelle <a href="commands/SetFormat.htm">Float-Format</a> zuzugreifen. Um Widersprüche zu vermeiden und die Verständlichkeit zu verbessern, sollte man vermeiden, direkt geschriebene Gleitkommazahlen als Keys zu verwenden.</li>
  <li>Standardmäßig kann mit dem Key "base" das <a href="#Custom_Objects">Base-Objekt</a> des Objekts abgerufen oder gesetzt werden, daher können diesem Key keine gewöhnlichen Werte auf normale Weise zugewiesen werden. Sobald aber andere Mittel zum Speichern eines Wertes benutzt werden (z. B. <code><a href="objects/Object.htm#RawSet">ObjRawSet</a>(Object, "base", "")</code> oder <code><a href="objects/Object.htm#SetCapacity">Object.SetCapacity</a>("base", 0)</code>), wird der Key "base" als normale Zeichenkette behandelt.</li>
  <li>Obwohl die Namen von <a href="objects/Object.htm">internen Methoden</a> wie "Length" als Keys verwendet werden können, verhindert das Speichern eines Wertes, dass die entsprechende Methode aufgerufen werden kann (es sei denn, dieser Wert selbst verweist auf die entsprechende Funktion, wie z. B. <em>ObjLength</em>).</li>
</ul>

<h2 id="Extended_Usage">Erweiterte Grundlagen</h2>
<h3 id="Function_References">Funktionsverweise <span class="ver">[v1.1.00+]</span></h3>
<p>Wenn die folgende Variable <i>funk</i> den Namen einer Funktion enthält, kann die Funktion wie folgt aufgerufen werden: <code>%funk%()</code> oder <code>funk.()</code>. Allerdings ist dies ineffizient, weil jedes Mal, wenn die Funktion aufgerufen wird, der Funktionsname aufgelöst werden muss. Um die Performance zu verbessern, kann der Verweis dieser Funktion in eine Variable gespeichert und später wiederverwendet werden:</p>
<pre>Funk := Func("MeineFunk")</pre>
<p>Mit der folgenden Syntax kann eine Funktion via Verweis aufgerufen werden:</p>
<pre>
RückWert := %Funk%(<i>Parameter</i>)     <em>; Benötigt <span class="ver">[v1.1.07+]</span></em>
RückWert := Funk.Call(<i>Parameter</i>)  <em>; Benötigt <span class="ver">[v1.1.19+]</span></em>
RückWert := Funk.(<i>Parameter</i>)      <em>; Nicht empfohlen</em>
</pre>
<p>Weitere Eigenschaften von Funktionsverweisen finden Sie unter <a href="objects/Func.htm">Func-Objekt</a>.</p>

<span id="JaggedArrays"></span><h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>AutoHotkey unterstützt "mehrdimensionale" Arrays, indem Arrays in andere Arrays gespeichert werden. Zum Beispiel repräsentieren die Reihen einer Tabelle die Felder eines Arrays, während die Felder selbst die Spalten der jeweiligen Reihe in Form eines Arrays enthalten. In diesem Fall kann der Inhalt der Spalte <code>y</code> von der Reihe <code>x</code> mit einer der folgenden Methoden gesetzt werden:</p>
<pre>Tabelle[x][y] := Inhalt  <em>; A</em>
Tabelle[x, y] := Inhalt  <em>; B</em></pre>
<p>Wenn <code>Tabelle[x]</code> nicht vorhanden ist, unterscheiden sich <span class="Code"><em>A</em></span> und <span class="Code"><em>B</em></span> wie folgt:</p>
<ul>
  <li><span class="Code"><em>A</em></span> schlägt fehl, während <span class="Code"><em>B</em></span> automatisch ein Objekt erstellt und es in <code>Tabelle[x]</code> speichert.</li>
  <li>Wenn  <code>Tabelle</code>'s <a href="#Custom_Objects">base</a> <a href="#Meta_Functions">Meta-Funktionen</a> bereitstellt, werden sie wie folgt aufgerufen:
  <pre>Tabelle.base.__Get(Tabelle, x)<span class="dull">[y] := Inhalt</span>   <em>; A</em>
Tabelle.base.__Set(Tabelle, x, y, Inhalt)     <em>; B</em></pre>
  Folglich kann durch <span class="Code"><em>B</em></span> das Objekt ein benutzerdefiniertes Verhalten für die gesamte Zuweisung definieren.</li>
</ul>
<p>Mehrdimensionale Zuweisungen wie <code>Tabelle[a, b, c, d] := Wert</code> werden wie folgt behandelt:</p>
<ul>
  <li>Wenn nur ein einziger Key übrig ist, führe die Zuweisung durch und gebe sie zurück. Ansonsten:</li>
  <li>Suche im Objekt den ersten Key in der Liste.</li>
  <li>Wenn ein Nicht-Objekt gefunden wird, schlage fehl.</li>
  <li>Wenn kein Objekt gefunden wird, erstelle eines und speichere es.</li>
  <li>Rufe das Unterobjekt rekursiv auf und übergebe die restlichen Keys und Values - beginne wieder von oben.</li>
</ul>
<p>Dieses Verhalten gilt nur für via Skript erstellte Objekte, nicht für spezielle Objekttypen wie COM-Objekte oder COM-Arrays.</p>

<span id="FuncArrays"></span><h3 id="Usage_Arrays_of_Functions">Arrays mit Funktionen</h3>
<p>Ein Array mit Funktionen ist im Prinzip ein Array, das Funktionsnamen oder Verweise enthält. Zum Beispiel:</p>
<pre>array := [Func("ErsteFunk"), Func("ZweiteFunk")]

<em>; Rufe jede Funktion auf und übergebe "foo" als Parameter:</em>
Loop 2
    array[A_Index].Call("foo")

<em>; Rufe jede Funktion auf und übergebe das Array selbst als indirekter Parameter:</em>
Loop 2
    array[A_Index]()

ErsteFunk(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}
ZweiteFunk(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}</pre>
<p>Aus Gründen der Abwärtskompatibilität wird die zweite Form das <i>array</i> nicht als Parameter übergeben, wenn <code>array[A_Index]</code> einen Funktionsnamen anstelle eines Funktionsverweises enthält. Wenn aber <code>array[A_Index]</code> von <code>array.base[A_Index]</code> <a href="#Custom_Objects">geerbt</a> wurde, wird das <i>array</i> als Parameter übergeben.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Objekte, die das Skript erstellt hat, müssen nicht zwingend eine vordefinierte Struktur haben. Stattdessen kann jedes Objekt Eigenschaften und Methoden von seinem <code>base</code>-Objekt (auch bekannt als "Prototyp" oder "Klasse") erben. Einem Objekt können jederzeit Eigenschaften und Methoden hinzugefügt (oder entfernt) werden; solche Änderungen haben auf alle abgeleiteten Objekte eine Auswirkung. Für komplexere oder speziellere Situationen kann ein Base-Objekt mithilfe von <a href="#Meta_Functions"><i>Meta-Funktionen</i></a> das Standardverhalten von jedem abgeleiteten Objekt überschreiben.</p>
<p><em>Base</em>-Objekte sind ganz normale Objekte, die wie folgt erstellt werden können:</p>
<pre>class baseObject {
    static foo := "bar"
}
<em>; OR</em>
baseObject := {foo: "bar"}</pre>
<p>Um ein Objekt zu erstellen, das von einem anderen Objekt abgeleitet wurde, können Skripte diesem Objekt die <code>base</code>-Eigenschaft zuweisen oder das <a href="#Custom_NewDelete"><code>new</code>-Schlüsselwort</a> verwenden:</p>
<pre>obj1 := Object(), obj1.base := baseObject
obj2 := {base: baseObjekt}
obj3 := new baseObjekt
MsgBox % obj1.foo " " obj2.foo " " obj3.foo</pre>
<p>Es ist jederzeit möglich, einem Objekt ein neues <code>base</code> zuzuweisen, um alle Eigenschaften und Methoden, die das Objekt geerbt hat, nachhaltig zu ersetzen.</p>

<h3 id="Custom_Prototypes">Prototypen</h3>
<p>Prototypen oder <code>base</code>-Objekte werden wie jedes andere Objekt auch konstruiert und manipuliert. Das folgende Beispiel zeigt, wie ein gewöhnliches Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Erstellt ein Objekt.</em>
obj := {}
<em>; Speichert einen Wert.</em>
obj.foo := "bar"
<em>; Erstellt eine Methode durch Speichern eines Funktionsverweises.</em>
obj.test := Func("obj_test")
<em>; Ruft die Methode auf.</em>
obj.test()

obj_test(this) {
   MsgBox % this.foo
}</pre>
<p>Sobald <code>obj.test()</code> aufgerufen wird, wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Für die Abwärtskompatibilität wird das aber nicht passieren, wenn eine Funktion direkt per Name (statt per Verweis) in das Objekt gespeichert wird (statt von einem Base-Objekt geerbt zu werden). Standardmäßig wird der Name der Funktion aus folgenden Komponenten gebildet: der "Typ" des Objekts und der Name der Methode.</p>
<p>Ein Objekt ist ein <i>Prototyp</i> oder <i>base</i>, wenn es von einem anderen Objekt abgeleitet wird:</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p>In diesem Fall erbt <i>anderesObj</i> das <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch - das heißt, wenn <code>obj.foo</code> modifiziert wird, wird <code>anderesObj.foo</code> diese Änderung widerspiegeln. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Einfluss auf <code>anderesObj.foo</code>. Sobald <code>anderesObj.test()</code> aufgerufen wird, enthält ihr <i>this</i>-Parameter einen Verweis auf <i>anderesObj</i> statt auf <i>obj</i>.
</p>

<h3 id="Custom_Classes">Klassen <span class="ver">[v1.1.00+]</span></h3>
<p>Eine "Klasse" ist im Grunde eine Gruppe oder Kategorie von Dingen, die Eigenschaften oder Attribute gemeinsam nutzen. Da ein <a href="#Custom_Objects">Base</a>- oder <a href="#Custom_Prototypes">Prototyp</a>-Objekt Eigenschaften und Verhaltensweisen für eine Gruppe von Objekten definiert, kann es auch als <em>Klassen</em>objekt bezeichnet werden. Das folgende Beispiel zeigt, wie auf einfache Weise Base-Objekte mithilfe des Schlüsselworts "class" definiert werden können:</p>
<pre>class Klassenname extends BaseKlassenname
{
    InstanzVar := Ausdruck
    static KlassenVar := Ausdruck

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }

    Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
    {
        get {
            return ...
        }
        set {
            return ... := Wert
        }
    }
}
</pre>
<p>Dieses Beispiel konstruiert, nachdem das Skript geladen wurde, ein Objekt und speichert es in die globale (oder <span class="ver">[in v1.1.05+]</span> in die <a href="Functions.htm#SuperGlobal">superglobale</a>) Variable <i>Klassenname</i>. Um diese Klasse innerhalb einer <a href="Functions.htm#ForceLocal">Force-Local</a>-Funktion (oder vor <span class="ver">[v1.1.05]</span> innerhalb einer Assume-Local- oder Assume-Static-Funktion) zu verweisen, ist eine Deklaration wie <code>global Klassenname</code> notwendig. Wenn <code>extends BaseKlassenname</code> vorhanden ist, muss der <i>BaseKlassenname</i> der vollständige Name einer anderen Klasse sein (in <span class="ver">[v1.1.11+]</span> spielt die Reihenfolge, in der sie definiert werden, keine Rolle mehr). Der vollständige Name jeder Klasse ist in <code><i>objekt</i>.__Class</code> gespeichert.</p>
<p>Da die Klasse via Variable verwiesen wird, kann der Klassenname nicht genutzt werden, um im selben Kontext sowohl die Klasse zu verweisen als auch eine separate Variable zu erstellen (um z. B. eine Instanz der Klasse zu enthalten). Zum Beispiel würde <code>box := new Box</code> das Klassenobjekt in <em>Box</em> mit einer Instanz von sich selbst ersetzen. <span class="ver">[v1.1.27+]:</span> <a href="commands/_Warn.htm#ClassOverwrite">#Warn ClassOverwrite</a> aktiviert eine Warnung, die angezeigt wird, wenn Sie versuchen, eine Klasse zu überschreiben.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen <span class="ver">[v1.1.01+]</span></h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse (also jedes Objekt, das von der Klasse abgeleitet wurde) eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert, ohne dass das Präfix <code>this.</code> angegeben werden muss (dies gilt nur in der Klassendefinition):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit dem <a href="#Custom_NewDelete">new</a>-Schlüsselwort erstellt wird. Für diesen Zweck ist der Methodenname <code>__Init</code> reserviert und sollte daher nicht vom Skript verwendet werden. Die <a href="#Custom_NewDelete">__New()</a>-Methode wird aufgerufen, sobald alle Deklarationen dieser Art (auch solche, die in base-Klassen definiert wurden) ausgewertet worden sind. <em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, aber alle anderen Variablenverweise werden als global angesehen.</p>
<p>Um auf eine Instanzvariable zugreifen zu können (sogar innerhalb einer Methode), gibt man immer das Zielobjekt an; zum Beispiel <code><b>this</b>.InstanzVar</code>.</p>
<p><span class="ver">[v1.1.08+]:</span> Deklarationen wie <code>x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>x := {}, x.y := 42</code> würde beispielsweise <code>x</code>  deklarieren und außerdem <code>this.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen <span class="ver">[v1.1.00.01+]</span></h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, die aber von abgeleiteten Objekten (einschließlich Unterklassen) geerbt werden können. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlassenVar := Ausdruck</pre>
<p>Statische Deklarationen werden nur einmal ausgewertet - bevor der <a href="Scripts.htm#auto">automatische Ausführungsbereich</a> erfolgt, und in der Reihenfolge, wie sie im Skript vorkommen. Jede Deklaration speichert einen Wert in das Klassenobjekt. Jeder Variablenverweis in <i>Ausdruck</i> wird als global angesehen.</p>
<p>Um einer Klassenvariable etwas zuweisen zu können, gibt man immer das Klassenobjekt an; zum Beispiel <code><b>Klassenname</b>.KlassenVar := Wert</code>. Wenn ein Objekt <em>x</em> von <em>Klassenname</em> abgeleitet wurde und wenn <em>x</em> selbst nicht den Key "KlassenVar" enthält, kann mit <code>x.KlassenVar</code> zudem der Wert von <code>Klassenname.KlassenVar</code> dynamisch abgerufen werden. Allerdings würde <code>x.KlassenVar := y</code> den Wert nicht in <em>Klassenname</em>, sondern in <em>x</em> speichern.</p>
<p><span class="ver">[v1.1.08+]:</span> Deklarationen wie <code>static x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>static x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code><i>Klassenname</i>.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Mit verschachtelten Klassendefinitionen können Klassenobjekte innerhalb von anderen Klassenobjekten gespeichert werden, ohne dass separat eine globale Variable verwendet werden muss. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein Objekt und speichert es in <code>Klassenname.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code>new this.VerschachtelteKlasse</code> eine geeignete Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der üblicherweise einen Verweis auf ein von der Klasse abgeleitetes Objekt enthält. Allerdings kann dieser Parameter auch einen Verweis auf die Klasse selbst oder auf eine abgeleitete Klasse enthalten, je nachdem, wie die Methode aufgerufen wurde. Methoden werden <a href="#Function_References">per Verweis</a> in das Klassenobjekt gespeichert.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p id="Custom_Classes_base">Innerhalb einer Methode kann das Pseudo-Schlüsselwort <code>base</code> verwendet werden, um auf Super-Klassen-Versionen von Methoden oder auf Eigenschaften, die in einer abgeleiteten Klasse überschrieben werden, zugreifen zu können. <code>base.Methode()</code> in der Klasse oben würde beispielsweise bewirken, dass eine Version von <em>Methode</em> aufgerufen wird, die über <em>BaseKlassenname</em> definiert wurde. <a href="#Meta_Functions">Meta-Funktionen</a> werden nicht aufgerufen; ansonsten verhält sich <code>base.Methode()</code> wie <code>BaseKlassenname.Methode.Call(this)</code>. Das heißt,</p>
<ul>
  <li>dass <code>base.Methode()</code> immer dort das Base der Klasse aufruft, wo die aktuelle Methode definiert wurde, egal ob <code>this</code> von einer <em>Unterklasse</em> aus dieser Klasse oder von einer ganz anderen Klasse abgeleitet worden ist.</li>
  <li>dass <code>base.Methode()</code> implizit <code>this</code> als ersten (versteckten) Parameter übergibt.</li>
</ul>
<p><code>base</code> hat nur eine besondere Bedeutung, wenn danach ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> erfolgt, demzufolge wird so etwas wie <code>obj := base, obj.Methode()</code> nicht funktionieren. Skripte können das spezielle Verhalten von <i>base</i> deaktivieren, indem sie dieser Sondervariable einen nicht-leeren Wert zuweisen; dies wird jedoch nicht empfohlen. Da die Variable <i>base</i> leer sein muss, kann die Performance reduziert sein, wenn das Skript <a href="commands/_NoEnv.htm">#NoEnv</a> weglässt.</p>

<h4 id="Custom_Classes_property">Eigenschaften <span class="ver">[v1.1.16+]</span></h4>
<p>Eigenschaftsdefinitionen erlauben das Ausführen einer Methode, wann immer das Skript einen spezifischen Key abruft oder setzt.</p>
<pre>Eigenschaft[]
{
    get {
        return ...
    }
    set {
        return ... := value
    }
}</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, mit dem sie aufgerufen werden kann. <code>obj.Eigenschaft</code> würde beispielsweise <em>get</em> aufrufen, und <code>obj.Eigenschaft := Wert</code> würde <em>set</em> aufrufen. Innerhalb von  <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der zugewiesen wird.</p>
<p>Beim Definieren oder Aufrufen einer Eigenschaft können Parameter übergeben werden, indem man sie auf der rechten Seite des Eigenschaftsnamens in eckigen Klammern setzt. Abgesehen von den eckigen Klammern werden Eigenschaftsparameter genauso wie Methodenparameter definiert - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Der Rückgabewert von <em>get</em> oder <em>set</em> ist das Ergebnis eines Teilausdrucks, der die Eigenschaft aufgerufen hat. Zum Beispiel würde <code>Wert := obj.Eigenschaft := 42</code> den Rückgabewert von <em>set</em> in <code>Wert</code> speichern.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_base">base.Eigenschaft</a></code> benutzen, um auf die via eigene Base-Klasse definierte Eigenschaft zugreifen zu können. Wenn <em>get</em> oder <em>set</em> nicht definiert ist, kann es von einer Base-Klasse behandelt werden. Wenn <em>set</em> nicht definiert ist und nicht von einer Meta-Funktion oder Base-Klasse behandelt wird, führt das Zuweisen eines Wertes dazu, dass dieser Wert in das Objekt gespeichert wird, wodurch die Eigenschaft deaktiviert wird.</p>
<p>Intern sind <em>get</em> und <em>set</em> zwei unterschiedliche Methoden, die sich untereinander keine Variablen teilen können (es sei denn, man speichert sie in <code>this</code>).</p>
<p><a href="#Meta_Functions">Meta-Funktionen</a> bieten eine breitere Auswahl an Möglichkeiten für den kontrollierten Zugriff auf Eigenschaften und Methoden eines Objekts, allerdings sind sie komplizierter und fehleranfälliger.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Immer wenn ein abgeleitetes Objekt mit dem Schlüsselwort <code>new</code> erstellt wird <span class="ver">[benötigt v1.1.00+]</span>, wird die via Base-Objekt definierte <code>__New</code>-Methode aufgerufen. Diese Methode kann Parameter akzeptieren, das Objekt initialisieren und das Ergebnis des <code>new</code>-Operators durch Zurückgeben eines Wertes überschreiben. Zerstört man ein Objekt, wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := new GMem(0, 20)
m2 := {base: GMem}.__New(0, 30)

class GMem
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            return ""
        MsgBox % "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
        return this  <em>; Diese Zeile kann weggelassen werden, wenn der Operator 'new' verwendet wird.</em>
    }

    __Delete()
    {
        MsgBox % "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht bei Objekten aufgerufen, die den Key "__Class" haben. <a href="#Custom_Classes">Klassenobjekte</a> haben standardmäßig diesen Key.</p>
<p><span class="ver">[v1.1.28+]:</span> Wenn eine Ausnahme oder ein Laufzeitfehler ausgelöst wird, während __Delete ausgeführt wird, und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen wurden. Das heißt, dass eine Fehlermeldung angezeigt und __Delete durchgeführt wird, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet). Vor v1.1.28 war es so, dass unbehandelte Ausnahmen ein inkonsistentes Verhalten verursachten.</p>

<h3 id="Meta_Functions">Meta-Funktionen</h3>
<pre class="Syntax">
<strong>Methodensyntax:</strong>
class <i>Klassenname</i> {
    __Get([Key, Key2, ...])
    __Set([Key, Key2, ...], Value)
    __Call(Name [, Parameter...])
}

<strong>Funktionssyntax:</strong>
<i>MeinGet</i>(this [, Key, Key2, ...])
<i>MeinSet</i>(this [, Key, Key2, ...], Value)
<i>MeinCall</i>(this, Name [, Parameter...])

<i>Klassenname</i> := { __Get: Func("<i>MeinGet</i>"), __Set: Func("<i>MeinSet</i>"), __Call: Func("<i>MeinCall</i>") }
</pre>
<p>Meta-Funktionen definieren, was passieren soll, wenn ein Key angefordert, aber nicht im Zielobjekt gefunden wird. Wenn einem <code>obj.key</code> beispielsweise keinen Wert zugewiesen wurde, wird die <i>__Get</i>-Meta-Funktion aufgerufen. <code>obj.key := value</code> veranlasst hingegen den Aufruf von <i>__Set</i> und <code>obj.key()</code> den Aufruf von <i>__Call</i>. Diese Meta-Funktionen (oder Methoden) sollten in <code>obj.base</code>, <code>obj.base.base</code> oder so ähnlich definiert sein.</p>
<p>Wenn das Skript einen nicht vorhandenen Key im Zielobjekt abruft (get), setzt (set) oder aufruft (call), wird das Base-Objekt wie folgt aufgerufen:</p>
<ul class="list_of_p">
  <li>Wenn dieses Base-Objekt die entsprechende Meta-Funktion definiert hat, rufe es auf. Wenn die Meta-Funktion etwas explizit via <code>return</code> zurückgibt, verwende den Rückgabewert als Ergebnis der Operation (was auch immer den Aufruf der Meta-Funktion verursacht hat) und übergebe die Kontrolle wieder an das Skript. Ansonsten mache weiter wie unten beschrieben.
    <p><i>Set</i>: Wenn die Meta-Funktion eine Zuweisung behandelt hat, sollte sie den zugewiesenen Wert zurückgeben. Auf diese Weise können Zuweisungen verkettet werden, wie z. B. <code>a.x := b.y := z</code>. Der Rückgabewert könnte vom ursprünglichen Wert <code>z</code> abweichen (wenn beispielsweise Beschränkungen auferlegt wurden, welche Werte zugewiesen werden dürfen).</p></li>
  <li>Suche nach einem passenden Key in den Feldern des Base-Objekts.</li>
  <li><span class="ver">[v1.1.16+]:</span> Wenn ein Key, der zu einer Eigenschaft gehört, gefunden wurde und <em>get</em> oder <em>set</em> durchführt (falls zutreffend), rufe die Eigenschaft auf und kehre zurück. Wenn dies ein Methodenaufruf ist, rufe <em>get</em> auf.</li>
  <li>Wenn kein einziger Key gefunden wurde, rufe das Base des Base-Objekts auf (wende dabei jeden dieser Schritte an, beginnend vom Anfang der Liste). Wenn wir noch nicht fertig sind, durchsuche dieses Base-Objekt nochmals nach einen passendem Key, falls ein Key via Meta-Funktion hinzugefügt wurde.
    <p>Aufgrund der Abwärtskompatibilität wird dieser Schritt für <em>set</em>-Operationen durchgeführt, selbst wenn ein Key gefunden wurde (es sei denn, es ist eine Eigenschaft definiert, die <em>set</em> durchführt).</p></li>
  <li>Wenn mehrere Parameter bei <i>get</i> oder <i>set</i> angegeben sind und ein Key gefunden wurde, überprüfe seinen Wert. Wenn dieser Wert ein Objekt ist, rufe es auf, um die restlichen Parameter zu behandeln, und tue nichts weiter.</li>
  <li>Wenn ein Key gefunden wurde,<br>
    <i>Get</i>: Gebe den Wert zurück.<br>
    <i>Call</i>: Versuch den Wert aufzurufen und übergebe das Zielobjekt als ersten Parameter (<code>this</code>). Der Wert sollte der Name einer Funktion oder <a href="objects/Functor.htm">Funktionsobjekt</a> sein.</li>
</ul>
<p>Wenn eine Meta-Funktion einen passenden Key im Objekt beinhaltet, aber keinen <code>return</code> verwendet, verhält sie sich so, als wäre der Key bereits zu Beginn im Objekt da gewesen. Um zu erfahren, wie __Set funktioniert, siehe <a href="#Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</a>.</p>
<p>Wenn die Operation immer noch nicht behandelt wurde, überprüfe, ob es eine interne Methode oder Eigenschaft ist:</p>
<ul>
  <li><i>Get</i>: Wenn der Key "base" ist, gebe das Base des Objekts zurück.</li>
  <li><i>Set</i>: Wenn der Key "base" ist, setze das Base des Objekts (oder entferne es, wenn der Wert kein Objekt ist).</li>
  <li><i>Call</i>: Rufe eine <a href="objects/Object.htm">interne Methode</a> auf, falls zutreffend.</li>
</ul>
<p>Wenn die Operation immer noch nicht behandelt wurde,</p>
<ul>
  <li><i>Get</i> und <i>Call</i>: Gebe eine leere Zeichenkette zurück.</li>
  <li><i>Set</i>: Wenn nur ein Key-Parameter angegeben wurde, speichere den Key und Wert in das Zielobjekt und gebe den zugewiesenen Wert zurück. Wenn mehrere Parameter angegeben wurden, erstelle ein neues Objekt und speichere es, und verwende dabei den ersten Parameter als Key; rufe dann das neue Objekt auf, um die restlichen Parameter zu behandeln. (Siehe <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>.)</li>

</ul>

<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Das Verwenden von <code>return</code> ohne Wert ist dasselbe wie <code>return ""</code>. Dieser Einschränkung wird eventuell in einer zukünftigen Version geändert, um mit <code>return</code> eine Meta-Funktion "verlassen" zu können, ohne dass das Standardverhalten überschrieben wird.</li></ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Mit der <a href="#Custom_Classes_property">Eigenschaftssyntax</a> können Eigenschaften definiert werden, die jedes Mal, wenn sie ausgewertet werden, einen Wert berechnen, allerdings muss jede Eigenschaft im Voraus bekannt sein und einmalig im Skript vorkommen. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die nicht im Voraus bekannt sein müssen.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Auch wenn der Name jeder Eigenschaft im Voraus bekannt war, wäre es unlogisch, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe tun würde (eine Netzwerkanfrage senden). Meta-Funktionen bekommen den Namen der Eigenschaft als Parameter, demzufolge sind sie eine gute Lösung für dieses Problem.</p>
<p><em>__Get</em> und <em>__Set</em> sind auch nützlich, um eine Reihe von verwandten Eigenschaften zu implementieren, die Code unter sich aufteilen. In dem Beispiel unten werden sie verwendet, um ein "Farbe"-Objekt mit R, G, B und RGB-Eigenschaften zu implementieren, wo tatsächlich nur der RGB-Wert gespeichert wird:</p>
<pre>rot := new Farbe(0xff0000), rot.R -= 5
cyan := new Farbe(0), cyan.G := 255, cyan.B := 255

MsgBox % "rot: " rot.R "," rot.G "," rot.B " = " rot.RGB
MsgBox % "cyan: " cyan.R "," cyan.G "," cyan.B " = " cyan.RGB

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    static Verschiebung := {R:16, G:8, B:0}

    __Get(aName)
    {
        <em>; <span class="red">HINWEIS:</span> this.Verschiebung würde hier eine Endlosschleife erzeugen!</em>
        Verschiebung := Farbe.Verschiebung[aName]  <em>; Ermittelt die Anzahl der zu verschiebenden Bits.</em>
        if (Verschiebung != "")  <em>; Ist sie eine bekannte Eigenschaft?</em>
            return (this.RGB &gt;&gt; Verschiebung) &amp; 0xff
        <em>; <span class="red">HINWEIS:</span> Ein 'return' hier würde this.RGB unbrauchbar machen.</em>
    }

    __Set(aName, aWert)
    {
        if ((Verschiebung := Farbe.Verschiebung[aName]) != "")
        {
            aWert &amp;= 255  <em>; Kürzt es auf eine geeignete Länge.

            ; Errechnet und speichert den neuen RGB-Wert.</em>
            this.RGB := (aWert &lt;&lt; Verschiebung) | (this.RGB &amp; ~(0xff &lt;&lt; Verschiebung))

            <em>; 'Return' ist notwendig, um die Erstellung eines neuen Key-Value-Paares zu verhindern.
            ; Dies bestimmt auch, was in dem 'x' in 'x := clr[name] := val' gespeichert wird:</em>
            return aWert
        }
        <em>; <span class="red">HINWEIS:</span> Ein 'return' hier würde this._RGB und this.RGB unbrauchbar machen.</em>
    }

    <em>; Meta-Funktionen können mit Eigenschaften vermischt werden:</em>
    RGB {
        get {
            <em>; Als Hex-Wert zurückgeben:</em>
            return format("0x{:06x}", this._RGB)
        }
        set {
            return this._RGB := value
        }
    }
}</pre>
<p>In diesem Fall hätte man stattdessen die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> verwenden können, um den Code unter den Eigenschaften aufteilen zu lassen, indem sie alle eine zentrale Methode aufrufen. Meta-Funktionen sollte man wenn möglich vermeiden, da ein hohes Risiko besteht, dass sie falsch verwendet werden (siehe die roten Hinweise oben).</p>

<h4 id="Objects_as_Functions">Objekte als Funktionen</h4>
<p>Siehe <a href="objects/Functor.htm#User-Defined">Funktionsobjekte</a>, wie Objekte geändert werden können, um sie wie Funktionen verhalten zu lassen.</p>
<p>Ein Funktionsobjekt kann sich auch wie eine Meta-Funktion verhalten, um z. B. dynamische Eigenschaften wie im vorherigen Abschnitt zu definieren. Obwohl es ratsam ist, immer die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> zu benutzen, zeigt das folgende Beispiel, wie nützlich Meta-Funktionen sein können, um neue Konzepte oder Verhaltensmuster zu implementieren, oder um die Struktur des Skripts zu ändern.</p>
<pre>blau := new Farbe(0x0000ff)
MsgBox % blau.R "," blau.G "," blau.B

class Eigenschaften extends <a href="objects/Functor.htm#class_FunctionObject">Funktionsobjekt</a>
{
    __Call(aTarget, aName, aParams*)
    {
        <em>; Falls dieses Eigenschaften-Objekt eine Definition für diese Halb-Eigenschaft enthält, rufe es auf.</em>
        if ObjHasKey(this, aName)
            return this[aName].Call(aZiel, aParams*)
    }
}

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    class __Get extends Eigenschaften
    {
        R() {
            return (this.RGB &gt;&gt; 16) &amp; 255
        }
        G() {
            return (this.RGB &gt;&gt; 8) &amp; 255
        }
        B() {
            return this.RGB &amp; 255
        }
    }

    <em>;...</em>
}</pre>

<h4 id="Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</h4>
<p>Ein Objekt, das indirekt via <a href="#Usage_Arrays_of_Arrays">Multiparameter-Zuweisung</a> wie <code>Tabelle[x, y] := Inhalt</code> erstellt wird, hat in der Regel kein Base und folglich keine benutzerdefinierten Methoden oder Sonderverhalten. Mit <code>__Set</code> können solche Objekte wie folgt initialisiert werden.</p>
<pre>x := {base: {addr: Func("x_Addr"), __Set: Func("x_Setter")}}

<em>; Weist einen Wert zu, und ruft indirekt x_Setter auf, um Unterobjekte zu erstellen.</em>
x[1,2,3] := "..."

<em>; Ermittelt den Wert und ruft die Beispielmethode auf.</em>
MsgBox % x[1,2,3] "`n" x.addr() "`n" x[1].addr() "`n" x[1,2].addr()

x_Setter(x, p1, p2, p3) {
    x[p1] := new x.base
}

x_Addr(x) {
    return &amp;x
}</pre>
<p><code>x_Setter</code> hat vier Pflichtparameter und kann daher nur aufgerufen werden, wenn zwei oder mehr Key-Parameter vorhanden sind. Erfolgt die oben genannte Zuweisung, findet folgendes statt:</p>
<ul>
  <li><code>x[1]</code> existiert nicht, daher wird <code>x_Setter(x,1,2,3)</code> aufgerufen (<code>"..."</code> wird nicht übergeben, da zu wenig Parameter vorhanden sind).
  <ul>
    <li><code>x[1]</code> wird ein neues Objekt mit demselben Base wie <code>x</code> zugewiesen.</li>
    <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2]</code> existiert nicht, daher wird <code>x_Setter(x[1],2,3,"...")</code> aufgerufen.
  <ul>
    <li>In <code>x[1][2]</code> wird ein neues Objekt mit demselben Base wie <code>x[1]</code> zugewiesen.</li>
    <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2][3]</code> existiert nicht, aber weil <code>x_Setter</code> vier Parameter benötigt und nur drei zur Verfügung stehen (<code>x[1][2], 3, "..."</code>), wird es nicht aufgerufen und die Zuweisung normal beendet.</li>
</ul>

<h2 id="Default_Base_Object">Standard-Base-Objekt</h2>
<p>Wenn ein objektloser Wert mit der Objektsyntax benutzt wird, wird das <i>Standard-Base-Objekt</i> aufgerufen. Dieses Objekt ist nützlich, um das Skript zu debuggen oder um Zeichenketten, Zahlen und/oder Variablen in globaler Hinsicht ein objektähnliches Verhalten zu geben. Der Zugriff auf das Standard-Base kann nur erfolgen, wenn <code>.base</code> mit irgendeinem objektlosen Wert verwendet wird; zum Beispiel <code>"".base</code>. Obwohl das Standard-Base nicht wie in <code>"".base := Object()</code> <i>gesetzt</i> werden kann, kann es selbst ein Base wie in <code>"".base.base := Object()</code> haben.</p>

<h4 id="Automatic_Var_Init">Automatische Variableninitialisierung</h4>
<p>Wenn eine leere Variable als Ziel einer <i>Set</i>-Operation bestimmt wurde, wird sie direkt an die __Set-Meta-Funktion übergeben, damit sie ein neues Objekt in die Variable einfügen kann. Aus Platzgründen unterstützt dieses Beispiel nicht mehr als ein Parameter; mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> wäre das möglich.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox % empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    if (var = "")
        var := Object(key, value)
}</pre>

<h4 id="Pseudo_Properties">Pseudo-Eigenschaften</h4>
<p>Diese Art von Syntax kann auch auf Zeichenketten und Zahlen angewendet werden.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox % A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox % A_AhkPath.length.is("integer")

Default_Get_PseudoProperty(nonobj, key)
{
    if (key = "length")
        return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    if nonobj is %type%
        return true
    return false
}</pre>
<p>Beachten Sie, dass interne Funktionen auch genutzt werden können, aber in diesem Fall dürfen die runden Klammern nicht weggelassen werden:</p>
<pre>"".base.length := Func("StrLen")
MsgBox % A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h4 id="Default__Warn">Debuggen</h4>
<p>Das folgende Beispiel zeigt, wie eine Warnmeldung angezeigt werden kann, wann immer ein objektloser Wert aufgerufen wird, um die Möglichkeit zu beseitigen, dass ein Wert als Objekt behandelt werden kann:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1="", p2="", p3="", p4="")
{
    ListLines
    MsgBox Ein objektloser Wert wurde unsachgemäß aufgerufen.`n`nSpeziell: %nonobj%
}</pre>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählungsmechanismus, um automatisch Ressourcen freizugeben, falls ein Objekt nicht länger in einem Skript benötigt bzw. verwiesen wird. Skript-Autoren sollten diesen Mechanismus nicht explizit aufrufen, es sei denn, sie müssen sich direkt mit unverwalteten <a href="#Implementation_Pointers">Objekt-Pointern</a> befassen.</p>
<p>In AutoHotkey v1.1 werden temporäre Verweise, die innerhalb eines Ausdrucks erstellt (aber nirgendwo gespeichert) werden, direkt nach ihrer Verwendung freigegeben. Zum Beispiel würde <code>Fn(&amp;{})</code> eine ungültige Adresse an die Funktion übergeben, weil der temporäre Verweis, zurückgegeben von <code>{}</code>, direkt nach dem Auswerten des <a href="Variables.htm#amp">Adresse-von</a>-Operators freigegeben wird.</p>
<p>Um eine Aktion nach Freigabe des letzten Objektverweises durchzuführen, implementiert man die <a href="#Custom_NewDelete">__Delete</a>-Meta-Funktion.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Siehe <a href="#Circular_References">Freigeben von Objekten</a>, um anhand eines Beispiels mehr darüber zu erfahren.</li>
  <li>Im Gegensatz zu Verweisen in statischen und globalen Variablen werden Verweise in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel nicht automatisch freigegeben, sobald das Programm beendet wird. Solche Verweise werden nur freigegeben, wenn die Funktion oder der Ausdruck regulär beendet werden kann.</li>
</ul>
<p>Obwohl das Betriebssystem den vom Objekt benutzten Speicher zurückfordert, sobald das Programm beendet wird, kann <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen werden, wenn alle Verweise auf das Objekt freigegeben worden sind. Das kann wichtig sein, wenn andere Ressourcen freigegeben werden, die nicht automatisch vom Betriebssystem zurückgefordert werden, wie zum Beispiel temporäre Dateien.</p>

<span id="AddressCast"></span><h3 id="Implementation_Pointers">Objekt-Pointer</h3>
<p>In einigen seltenen Fällen ist es eventuell erforderlich, dass ein Objekt via DllCall an einen externen Code übergeben werden muss, oder dass ein Objekt in eine binäre Datenstruktur gespeichert werden muss, damit es später abgerufen werden kann. Die Adresse eines Objekts kann via <code>Adresse := &amp;Objekt</code> abgerufen werden; dies würde allerdings effektiv zwei Verweise auf das Objekt erzeugen, während das Programm selbst nur den einen Verweis in <em>Objekt</em> kennt. Das Objekt wird gelöscht, sobald der letzte <em>bekannte</em> Verweis auf das Objekt freigegeben wird. Demzufolge muss das Skript das Objekt darüber informieren, dass es einen Verweis erhalten hat. Es gibt zwei Wege, um das zu erreichen:</p>
<pre><em>; Methode #1: Referenzzählung explizit erhöhen.</em>
Adresse := &amp;Objekt
<a href="commands/ObjAddRef.htm">ObjAddRef</a>(Adresse)

<em>; Methode #2: Object() benutzen, das die Referenzzählung erhöht und eine Adresse zurückgibt.</em>
Adresse := Object(Objekt)</pre>
<p>Mit dieser Funktion ist es auch möglich, eine Adresse wieder in ein Verweis zurückzuverwandeln:</p>
<pre>Objekt := Object(Adresse)</pre>
<p>In jedem Fall muss das Objekt informiert werden, wenn das Skript mit diesem Verweis fertig ist:</p>
<pre><em>; Verringert die Referenzzählung des Objekts, damit es freigegeben werden kann:</em>
<a href="commands/ObjAddRef.htm">ObjRelease</a>(Adresse)
</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separater Objektverweis behandelt werden, demzufolge sollte das Skript ObjAddRef aufrufen, wenn es eine Kopie erhält, und sofort ObjRelease aufrufen, bevor es eine verliert. Zum Beispiel sollte immer ObjAddRef aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript ObjRelease aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist den Wert von <em>x</em> zu überschreiben).</p>
<p>Beachten Sie, dass die Object()-Funktion sogar auf Objekte angewendet werden kann, die sie selbst nicht erstellt hat, wie z. B. <a href="commands/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="objects/File.htm">File-Objekte</a>.</p>

</body>
</html>
